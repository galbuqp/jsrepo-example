import*as o from'valibot';import v from'chalk';import {Octokit}from'octokit';var D=o.object({name:o.string(),category:o.string(),localDependencies:o.array(o.string()),dependencies:o.array(o.string()),devDependencies:o.array(o.string()),tests:o.boolean(),list:o.optional(o.boolean(),true),directory:o.string(),subdirectory:o.boolean(),files:o.array(o.string()),_imports_:o.record(o.string(),o.string())}),A=o.object({name:o.string(),blocks:o.array(D)}),W=o.object({authors:o.optional(o.array(o.string())),bugs:o.optional(o.string()),description:o.optional(o.string()),homepage:o.optional(o.string()),repository:o.optional(o.string()),tags:o.optional(o.array(o.string()))}),Y=o.record(o.string(),o.union([o.string(),o.object({version:o.string(),message:o.string()})])),G=o.object({name:o.string(),path:o.string(),expectedPath:o.optional(o.string()),optional:o.optional(o.boolean(),false)}),Q=o.object({...G.entries,dependencies:o.optional(o.array(o.string())),devDependencies:o.optional(o.array(o.string()))}),N=o.object({meta:o.optional(W),peerDependencies:o.optional(Y),configFiles:o.optional(o.array(Q)),categories:o.array(A)});var L="jsrepo-manifest.json",te="jsrepo.json";var Z="main",y={name:"azure",matches:r=>r.toLowerCase().startsWith("azure"),parse:(r,e)=>{let t=T(r,e);return {url:t.url,specifier:t.specifier}},baseUrl:r=>{let{owner:e,repoName:t}=T(r,{fullyQualified:false});return `https://dev.azure.com/${e}/_git/${t}`},state:async r=>{let{url:e,owner:t,project:s,repoName:c,ref:n,refs:i}=T(r,{fullyQualified:false});return {owner:t,repoName:c,ref:n,refs:i,project:s,url:e,provider:y}},resolveRaw:async(r,e)=>{if(r.provider.name!==y.name)throw new Error(`You passed the incorrect state object (${r.provider.name}) to the ${y.name} provider.`);let{owner:t,repoName:s,project:c,ref:n,refs:i}=r,a=i==="tags"?"tag":"branch";return new URL(`https://dev.azure.com/${t}/${c}/_apis/git/repositories/${s}/items?path=${e}&api-version=7.2-preview.1&versionDescriptor.version=${n}&versionDescriptor.versionType=${a}`)},authHeader:r=>["Authorization",`Bearer ${r}`],formatFetchError:(r,e)=>`There was an error fetching \`${v.bold(e)}\` from ${v.bold(r.url)}.

${v.bold("This may be for one of the following reasons:")}
1. Either \`${v.bold(e)}\` or the containing repository doesn't exist
2. Your repository path is incorrect (wrong branch, wrong tag)
3. You are using an expired access token or a token that doesn't have access to this repository
4. The cached state for this git provider is incorrect (try using ${v.bold("--no-cache")})
`},T=(r,{fullyQualified:e})=>{let t=r.replaceAll(/(azure\/)/g,""),[s,c,n,...i]=t.split("/"),a;e&&(a=i.slice(i.length-2).join("/"),i=i.slice(0,i.length-2));let p=Z,l="heads";return ["tags","heads"].includes(i[0])&&(l=i[0],i[1]&&i[1]!==""&&(p=i[1])),{url:`azure/${s}/${c}/${n}${p?`/${l}/${p}`:""}`,owner:s,repoName:n,project:c,ref:p,refs:l,specifier:a}};var g=(r,e)=>{for(let t of e)if(r.startsWith(t))return  true;return  false},ne=(r,e)=>{for(let t of e)if(r.endsWith(t))return  true;return  false};var F="master",h={name:"bitbucket",matches:r=>g(r.toLowerCase(),["bitbucket","https://bitbucket.org"]),parse:(r,e)=>{let t=O(r,e);return {url:t.url,specifier:t.specifier}},baseUrl:r=>{let{owner:e,repoName:t}=O(r,{fullyQualified:false});return `https://bitbucket.org/${e}/${t}`},state:async(r,{token:e,fetch:t=fetch}={})=>{let{url:s,owner:c,repoName:n,ref:i}=O(r,{fullyQualified:false});if(i===void 0)try{let a=new Headers;if(e!==void 0){let[l,P]=h.authHeader(e);a.append(l,P);}let p=await t(`https://api.bitbucket.org/2.0/repositories/${c}/${n}`,{headers:a});p.ok?i=(await p.json()).mainbranch.name:i=F;}catch{i=F;}return {owner:c,ref:i,repoName:n,url:s,provider:h}},resolveRaw:async(r,e)=>{if(r.provider.name!==h.name)throw new Error(`You passed the incorrect state object (${r.provider.name}) to the ${h.name} provider.`);let{owner:t,repoName:s,ref:c}=r;return new URL(e,`https://api.bitbucket.org/2.0/repositories/${t}/${s}/src/${c}/`)},authHeader:r=>["Authorization",`Bearer ${r}`],formatFetchError:(r,e)=>`There was an error fetching \`${v.bold(e)}\` from ${v.bold(r.url)}.

${v.bold("This may be for one of the following reasons:")}
1. Either \`${v.bold(e)}\` or the containing repository doesn't exist
2. Your repository path is incorrect (wrong branch, wrong tag)
3. You are using an expired access token or a token that doesn't have access to this repository
4. The cached state for this git provider is incorrect (try using ${v.bold("--no-cache")})
`},O=(r,{fullyQualified:e=false})=>{let t=r.replaceAll(/(https:\/\/bitbucket.org\/)|(bitbucket\/)/g,""),[s,c,...n]=t.split("/"),i;e&&(i=n.slice(n.length-2).join("/"),n=n.slice(0,n.length-2));let a;return n[0]==="src"&&(a=n[1]),{url:`bitbucket/${s}/${c}${a?`/src/${a}`:""}`,specifier:i,owner:s,repoName:c,ref:a}};var z="main",$={name:"github",matches:r=>g(r.toLowerCase(),["github","https://github.com"]),parse:(r,e)=>{let t=k(r,e);return {url:t.url,specifier:t.specifier}},baseUrl:r=>{let{owner:e,repoName:t}=k(r,{fullyQualified:false});return `https://github.com/${e}/${t}`},state:async(r,{token:e}={})=>{let{url:t,owner:s,repoName:c,ref:n}=k(r,{fullyQualified:false}),i=new Octokit({auth:e}),a="heads";if(n===void 0)try{let{data:p}=await i.rest.repos.get({owner:s,repo:c});n=p.default_branch;}catch{n=z;}else if(n!==z)try{let{data:p}=await i.rest.git.listMatchingRefs({owner:s,repo:c,ref:"tags"});p.some(l=>l.ref===`refs/tags/${n}`)&&(a="tags");}catch{a="heads";}return {owner:s,refs:a,ref:n,repoName:c,url:t,provider:$}},resolveRaw:async(r,e)=>{if(r.provider.name!==$.name)throw new Error(`You passed the incorrect state object (${r.provider.name}) to the ${$.name} provider.`);let{owner:t,repoName:s,refs:c,ref:n}=r;return new URL(e,`https://raw.githubusercontent.com/${t}/${s}/refs/${c}/${n}/`)},authHeader:r=>["Authorization",`token ${r}`],formatFetchError:(r,e)=>`There was an error fetching \`${v.bold(e)}\` from ${v.bold(r.url)}.

${v.bold("This may be for one of the following reasons:")}
1. Either \`${v.bold(e)}\` or the containing repository doesn't exist
2. Your repository path is incorrect (wrong branch, wrong tag)
3. You are using an expired access token or a token that doesn't have access to this repository
4. The cached state for this git provider is incorrect (try using ${v.bold("--no-cache")})
`},k=(r,{fullyQualified:e=false})=>{let t=r.replaceAll(/(https:\/\/github.com\/)|(github\/)/g,""),[s,c,...n]=t.split("/"),i;e&&(i=n.slice(n.length-2).join("/"),n=n.slice(0,n.length-2));let a;return n.length>0&&n[0]==="tree"&&(a=n[1]),{url:`github/${s}/${c}${a?`/tree/${a}`:""}`,specifier:i,owner:s,repoName:c,ref:a}};var f=(...r)=>r.map(e=>K(e)).filter(Boolean).join("/"),K=r=>{let e=V(r);return q(e)};var V=r=>{let e=r;return e.startsWith("/")&&(e=e.slice(1)),e};var q=r=>{let e=r;return e.endsWith("/")&&(e=e.slice(0,e.length-1)),e},_=r=>{let e=r;return e.endsWith("/")||(e=`${e}/`),e};var B="main",m={name:"gitlab",matches:r=>g(r.toLowerCase(),["gitlab/","gitlab:","https://gitlab.com"]),parse:(r,e)=>{let t=j(r,e);return {url:t.url,specifier:t.specifier}},baseUrl:r=>{let{baseUrl:e,owner:t,repoName:s}=j(r,{fullyQualified:false});return f(e,t,s)},state:async(r,{token:e,fetch:t=fetch}={})=>{let{baseUrl:s,url:c,owner:n,repoName:i,ref:a}=j(r,{fullyQualified:false});if(a===void 0)try{let p=new Headers;if(e!==void 0){let[P,M]=m.authHeader(e);p.append(P,M);}let l=await t(f(s,`api/v4/projects/${encodeURIComponent(`${n}/${i}`)}`),{headers:p});l.ok?a=(await l.json()).default_branch:a=B;}catch{a=B;}return {owner:n,repoName:i,ref:a,baseUrl:s,url:c,provider:m}},resolveRaw:async(r,e)=>{if(r.provider.name!==m.name)throw new Error(`You passed the incorrect state object (${r.provider.name}) to the ${m.name} provider.`);let{baseUrl:t,owner:s,repoName:c,ref:n}=r;return new URL(f(t,`api/v4/projects/${encodeURIComponent(`${s}/${c}`)}`,`repository/files/${encodeURIComponent(e)}/raw?ref=${n}`))},authHeader:r=>["PRIVATE-TOKEN",r],formatFetchError:(r,e,t)=>`There was an error fetching \`${v.bold(e)}\` from ${v.bold(r.url)}: ${t}.

${v.bold("This may be for one of the following reasons:")}
1. Either \`${v.bold(e)}\` or the containing repository doesn't exist
2. Your repository path is incorrect (wrong branch, wrong tag)
3. You are using an expired access token or a token that doesn't have access to this repository
4. The cached state for this git provider is incorrect (try using ${v.bold("--no-cache")})
`},j=(r,{fullyQualified:e})=>{let t="https://gitlab.com";r.startsWith("gitlab:")&&(t=new URL(r.slice(7)).origin);let s=r.replaceAll(/gitlab\/|https:\/\/gitlab\.com\/|gitlab:https?:\/\/[a-zA-Z0-9-]+\.[a-zA-Z]+\//g,""),[c,n,...i]=s.split("/"),a;e&&(a=i.slice(i.length-2).join("/"),i=i.slice(0,i.length-2));let p;if(i[0]==="-"&&i[1]==="tree")if(i[2].includes("?")){let[l]=i[2].split("?");p=l;}else p=i[2];return {url:f(t,`${c}/${n}${p?`/-/tree/${p}`:""}`),baseUrl:t,owner:c,repoName:n,ref:p,specifier:a}};var S={name:"http",matches:r=>{try{return new URL(r),!0}catch{return  false}},parse:(r,e)=>{let t=U(r,e);return {url:t.url,specifier:t.specifier}},baseUrl:r=>{let{url:e}=U(r,{fullyQualified:false});return new URL(e).origin},state:async r=>{let{url:e}=U(r,{fullyQualified:false});return {url:e,provider:S}},resolveRaw:async(r,e)=>{if(r.provider.name!==S.name)throw new Error(`You passed the incorrect state object (${r.provider.name}) to the ${S.name} provider.`);return new URL(e,r.url)},authHeader:r=>["Authorization",`Bearer ${r}`],formatFetchError:(r,e,t)=>`There was an error fetching ${v.bold(new URL(e,r.url).toString())}
	
${v.bold(t)}`},U=(r,{fullyQualified:e})=>{let t=new URL(r),s=t.pathname.split("/"),c;return e&&(c=s.slice(s.length-2).join("/"),s=s.slice(0,s.length-2)),{url:_(f(t.origin,...s)),specifier:c}};var x=class{_result;constructor(e){this._result=e;}match(e,t){return this._result.ok?e(this._result.val):t(this._result.err)}map(e){return this.match(t=>d(e(t)),t=>u(t))}mapOr(e,t){return this.match(s=>t(s),s=>e)}mapOrElse(e,t){return this.match(s=>t(s),s=>e(s))}mapErr(e){return this.match(t=>d(t),t=>u(e(t)))}mapErrOr(e,t){return this.match(s=>e,s=>t(s))}mapErrOrElse(e,t){return this.match(s=>e(s),s=>t(s))}isOk(){return this.match(()=>true,()=>false)}isErr(){return this.match(()=>false,()=>true)}unwrap(){return this.match(e=>e,()=>{throw new Error("Attempted to call `.unwrap()` on a non `Ok` value.")})}unwrapErr(){return this.match(()=>{throw new Error("Attempted to call `.unwrapErr()` on a non `Err` value.")},e=>e)}unwrapOr(e){return this.match(t=>t,t=>e)}unwrapErrOr(e){return this.match(()=>e,t=>t)}unwrapOrElse(e){return this.match(t=>t,t=>e(t))}unwrapErrOrElse(e){return this.match(t=>e(t),t=>t)}expect(e){return this.match(t=>t,()=>{throw new Error(e)})}expectErr(e){return this.match(()=>{throw new Error(e)},t=>t)}},d=r=>new x({ok:true,val:r}),u=r=>new x({ok:false,err:r});var C=r=>{let e;try{e=JSON.parse(r);}catch(s){return u(`Error parsing manifest json ${s}`)}if(Array.isArray(e)){let s=o.safeParse(o.array(A),e);return s.success?d({categories:s.output}):u(`Error parsing categories (array-based config) ${s.issues.join(" ")}`)}let t=o.safeParse(N,e);return t.success?d(t.output):u(`Error parsing manifest ${t.issues.join(" ")}`)};var X=[$,m,h,y,S],Ue=r=>X.find(t=>t.matches(r)),ee=async(r,e,{verbose:t,fetch:s=fetch,token:c}={})=>{let n=await r.provider.resolveRaw(r,e);t?.(`Trying to fetch from ${n}`);try{let i=new Headers;if(c!==void 0&&r.provider.authHeader){let[p,l]=r.provider.authHeader(c);i.append(p,l);}let a=await s(n,{headers:i});return t?.(`Got a response from ${n} ${a.status} ${a.statusText}`),a.ok?d(await a.text()):u(r.provider.formatFetchError(r,e,`${a.status} ${a.statusText}`))}catch(i){return u(r.provider.formatFetchError(r,e,i))}},Ne=async(r,{fetch:e=fetch,...t}={})=>{let s=await ee(r,L,{fetch:e,...t});return s.isErr()?u(s.unwrapErr()):C(s.unwrap())};export{d as a,u as b,f as c,D as d,A as e,W as f,Y as g,G as h,Q as i,N as j,ne as k,L as l,te as m,C as n,y as o,h as p,$ as q,m as r,S as s,X as t,Ue as u,ee as v,Ne as w};//# sourceMappingURL=chunk-HDOB2X6K.js.map
//# sourceMappingURL=chunk-HDOB2X6K.js.map